<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>什么是垃圾回收（GC） | chew's blog</title><meta name="description" content="什么是垃圾回收（GC）"><meta name="keywords" content="JVM,垃圾回收"><meta name="author" content="chew"><meta name="copyright" content="chew"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="什么是垃圾回收（GC）"><meta name="twitter:description" content="什么是垃圾回收（GC）"><meta name="twitter:image" content="http://facai1983.top/img/GC.jpg"><meta property="og:type" content="article"><meta property="og:title" content="什么是垃圾回收（GC）"><meta property="og:url" content="http://facai1983.top/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/"><meta property="og:site_name" content="chew's blog"><meta property="og:description" content="什么是垃圾回收（GC）"><meta property="og:image" content="http://facai1983.top/img/GC.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://facai1983.top/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/"><link rel="prev" title="什么是内存泄漏和内存溢出" href="http://facai1983.top/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%BA%A2%E5%87%BA/"><link rel="next" title="二分查找篇-两个数组的交集部分" href="http://facai1983.top/2020/01/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AF%87-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E9%83%A8%E5%88%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">chew's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-link"></i><span> Picture</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/default.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">73</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">78</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">70</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-link"></i><span> Picture</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一-什么是GC"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一  什么是GC</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内存泄漏："><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">内存泄漏：</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#什么是内存泄漏："><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">什么是内存泄漏：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#为什么会发生内存泄漏："><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">为什么会发生内存泄漏：</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二-为什么要GC"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">二 为什么要GC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三-什么时候进行GC"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">三 什么时候进行GC</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-JDK1-2之前，引用记数法"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">1.JDK1.2之前，引用记数法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-JDK1-2之后，可达性分析算法"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">2.JDK1.2之后，可达性分析算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#目前java-中可作为GC-Root-的对象有"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">目前java 中可作为GC Root 的对象有</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四-JDK1-2之后将引用扩充为四种"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">四 JDK1.2之后将引用扩充为四种</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-强引用-Strong-Reference"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">1.强引用(Strong Reference)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-软引用-Soft-Reference"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">2.软引用(Soft Reference)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-弱引用-Weak-Reference"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">3.弱引用(Weak Reference)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-虚引用-Phantom-Reference"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">4.虚引用(Phantom Reference)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五-老年代和新生代，以及Minor-GC和Major-GC"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">五 老年代和新生代，以及Minor GC和Major GC</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-新生代"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">1.新生代</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-旧生代"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">2.旧生代</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-什么是Minor-GC和Major-GC"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">3.什么是Minor GC和Major GC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-什么时候进行Minor-GC"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">4.什么时候进行Minor GC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-什么时候进行Major-GC"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">5.什么时候进行Major GC</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六-垃圾收集算法"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">六 垃圾收集算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-标记清除算法-Mark-Sweep"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">1.标记清除算法 Mark-Sweep</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-复制算法-Copying"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">2.复制算法 Copying</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-标记整理算法-Mark-Compact"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">3.标记整理算法 Mark-Compact</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-分代收集算法-Generational-Collection"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">4.分代收集算法 Generational Collection</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七-垃圾收集器"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">七 垃圾收集器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-串行回收器"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">1.串行回收器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-概念"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">1.1 概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2-Serial收集器"><span class="toc_mobile_items-number">7.1.2.</span> <span class="toc_mobile_items-text">1.2 Serial收集器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-3-Serial-Old收集器"><span class="toc_mobile_items-number">7.1.3.</span> <span class="toc_mobile_items-text">1.3 Serial Old收集器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-并行回收器"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">2.并行回收器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-概念"><span class="toc_mobile_items-number">7.2.1.</span> <span class="toc_mobile_items-text">2.1 概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-ParNew收集器"><span class="toc_mobile_items-number">7.2.2.</span> <span class="toc_mobile_items-text">2.2 ParNew收集器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-Parallel-Scavenge收集器"><span class="toc_mobile_items-number">7.2.3.</span> <span class="toc_mobile_items-text">2.3 Parallel Scavenge收集器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-4-Parallel-Old收集器"><span class="toc_mobile_items-number">7.2.4.</span> <span class="toc_mobile_items-text">2.4 Parallel Old收集器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-并发回收器"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">3.并发回收器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#3-1-CMS-收集器"><span class="toc_mobile_items-number">7.3.1.</span> <span class="toc_mobile_items-text">3.1 CMS 收集器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-并行-并发回收器"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">4.并行+并发回收器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#4-1-G1收集器"><span class="toc_mobile_items-number">7.4.1.</span> <span class="toc_mobile_items-text">4.1 G1收集器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-总结"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">5.总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#八-内存分配原则"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">八 内存分配原则</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-对象优先在-Eden-分配"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">1.对象优先在 Eden 分配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-长期存活的对象将进入老年代"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">2.长期存活的对象将进入老年代</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-动态对象年龄判定"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">3.动态对象年龄判定</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-空间分配担保"><span class="toc_mobile_items-number">8.4.</span> <span class="toc_mobile_items-text">4.空间分配担保</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-什么是GC"><span class="toc-number">1.</span> <span class="toc-text">一  什么是GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏："><span class="toc-number">1.1.</span> <span class="toc-text">内存泄漏：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是内存泄漏："><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是内存泄漏：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么会发生内存泄漏："><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么会发生内存泄漏：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-为什么要GC"><span class="toc-number">2.</span> <span class="toc-text">二 为什么要GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-什么时候进行GC"><span class="toc-number">3.</span> <span class="toc-text">三 什么时候进行GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JDK1-2之前，引用记数法"><span class="toc-number">3.1.</span> <span class="toc-text">1.JDK1.2之前，引用记数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JDK1-2之后，可达性分析算法"><span class="toc-number">3.2.</span> <span class="toc-text">2.JDK1.2之后，可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#目前java-中可作为GC-Root-的对象有"><span class="toc-number">3.2.1.</span> <span class="toc-text">目前java 中可作为GC Root 的对象有</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-JDK1-2之后将引用扩充为四种"><span class="toc-number">4.</span> <span class="toc-text">四 JDK1.2之后将引用扩充为四种</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-强引用-Strong-Reference"><span class="toc-number">4.1.</span> <span class="toc-text">1.强引用(Strong Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-软引用-Soft-Reference"><span class="toc-number">4.2.</span> <span class="toc-text">2.软引用(Soft Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-弱引用-Weak-Reference"><span class="toc-number">4.3.</span> <span class="toc-text">3.弱引用(Weak Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-虚引用-Phantom-Reference"><span class="toc-number">4.4.</span> <span class="toc-text">4.虚引用(Phantom Reference)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-老年代和新生代，以及Minor-GC和Major-GC"><span class="toc-number">5.</span> <span class="toc-text">五 老年代和新生代，以及Minor GC和Major GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-新生代"><span class="toc-number">5.1.</span> <span class="toc-text">1.新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-旧生代"><span class="toc-number">5.2.</span> <span class="toc-text">2.旧生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-什么是Minor-GC和Major-GC"><span class="toc-number">5.3.</span> <span class="toc-text">3.什么是Minor GC和Major GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-什么时候进行Minor-GC"><span class="toc-number">5.4.</span> <span class="toc-text">4.什么时候进行Minor GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-什么时候进行Major-GC"><span class="toc-number">5.5.</span> <span class="toc-text">5.什么时候进行Major GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-垃圾收集算法"><span class="toc-number">6.</span> <span class="toc-text">六 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-标记清除算法-Mark-Sweep"><span class="toc-number">6.1.</span> <span class="toc-text">1.标记清除算法 Mark-Sweep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-复制算法-Copying"><span class="toc-number">6.2.</span> <span class="toc-text">2.复制算法 Copying</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-标记整理算法-Mark-Compact"><span class="toc-number">6.3.</span> <span class="toc-text">3.标记整理算法 Mark-Compact</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-分代收集算法-Generational-Collection"><span class="toc-number">6.4.</span> <span class="toc-text">4.分代收集算法 Generational Collection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-垃圾收集器"><span class="toc-number">7.</span> <span class="toc-text">七 垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-串行回收器"><span class="toc-number">7.1.</span> <span class="toc-text">1.串行回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-概念"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Serial收集器"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2 Serial收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Serial-Old收集器"><span class="toc-number">7.1.3.</span> <span class="toc-text">1.3 Serial Old收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-并行回收器"><span class="toc-number">7.2.</span> <span class="toc-text">2.并行回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-概念"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-ParNew收集器"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 ParNew收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Parallel-Scavenge收集器"><span class="toc-number">7.2.3.</span> <span class="toc-text">2.3 Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Parallel-Old收集器"><span class="toc-number">7.2.4.</span> <span class="toc-text">2.4 Parallel Old收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-并发回收器"><span class="toc-number">7.3.</span> <span class="toc-text">3.并发回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-CMS-收集器"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1 CMS 收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-并行-并发回收器"><span class="toc-number">7.4.</span> <span class="toc-text">4.并行+并发回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-G1收集器"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 G1收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-总结"><span class="toc-number">7.5.</span> <span class="toc-text">5.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-内存分配原则"><span class="toc-number">8.</span> <span class="toc-text">八 内存分配原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-对象优先在-Eden-分配"><span class="toc-number">8.1.</span> <span class="toc-text">1.对象优先在 Eden 分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-长期存活的对象将进入老年代"><span class="toc-number">8.2.</span> <span class="toc-text">2.长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-动态对象年龄判定"><span class="toc-number">8.3.</span> <span class="toc-text">3.动态对象年龄判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-空间分配担保"><span class="toc-number">8.4.</span> <span class="toc-text">4.空间分配担保</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://facai1983.top/img/GC.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">什么是垃圾回收（GC）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-01-19<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-01-20</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/JVM/">JVM</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>comments:</span><a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="一-什么是GC"><a href="#一-什么是GC" class="headerlink" title="一  什么是GC"></a>一  什么是GC</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用可达性分析的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>GC的可达性分析能够可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的。</p>
<p>程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h3 id="内存泄漏："><a href="#内存泄漏：" class="headerlink" title="内存泄漏："></a>内存泄漏：</h3><h4 id="什么是内存泄漏："><a href="#什么是内存泄漏：" class="headerlink" title="什么是内存泄漏："></a>什么是内存泄漏：</h4><p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉。</p>
<h4 id="为什么会发生内存泄漏："><a href="#为什么会发生内存泄漏：" class="headerlink" title="为什么会发生内存泄漏："></a>为什么会发生内存泄漏：</h4><p>java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</p>
<h2 id="二-为什么要GC"><a href="#二-为什么要GC" class="headerlink" title="二 为什么要GC"></a>二 为什么要GC</h2><p>随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。</p>
<h2 id="三-什么时候进行GC"><a href="#三-什么时候进行GC" class="headerlink" title="三 什么时候进行GC"></a>三 什么时候进行GC</h2><h3 id="1-JDK1-2之前，引用记数法"><a href="#1-JDK1-2之前，引用记数法" class="headerlink" title="1.JDK1.2之前，引用记数法"></a>1.JDK1.2之前，引用记数法</h3><p>每个对象添加一个引用计数器，每被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象就认为是可以被回收得了。（在JDK1.2之前，使用的是该算法）<br>缺点：当两个对象A、B相互引用的时候，当其他所有的引用都消失之后，A和B还有一个相互引用，此时计数器各为1，而实际上这两个对象都已经没有额外的引用了，已经是垃圾了。但是却不会被回收。</p>
<h3 id="2-JDK1-2之后，可达性分析算法"><a href="#2-JDK1-2之后，可达性分析算法" class="headerlink" title="2.JDK1.2之后，可达性分析算法"></a>2.JDK1.2之后，可达性分析算法</h3><p>该算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>


<h4 id="目前java-中可作为GC-Root-的对象有"><a href="#目前java-中可作为GC-Root-的对象有" class="headerlink" title="目前java 中可作为GC Root 的对象有"></a>目前java 中可作为GC Root 的对象有</h4><ol>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>本地方法栈中引用的对象（Native Object）</li>
<li>方法区中常量引用的对象</li>
<li>方法区中静态属性引用的对象</li>
</ol>
<h2 id="四-JDK1-2之后将引用扩充为四种"><a href="#四-JDK1-2之后将引用扩充为四种" class="headerlink" title="四 JDK1.2之后将引用扩充为四种"></a>四 JDK1.2之后将引用扩充为四种</h2><p>如果在某一段时间内，该对象没有被使用，JVM可能就要对资源进行回收了，但是等到下一秒要用的时候，发现已经回收，只能重新去new了，这样就会降低JVM的效率了。那么对这些暂时闲下来的对象，有没有好的处理办法呢？</p>
<p>于是JDK 1.2之后，引用进行了扩充，引入了强、软、若、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义：</p>
<h3 id="1-强引用-Strong-Reference"><a href="#1-强引用-Strong-Reference" class="headerlink" title="1.强引用(Strong Reference)"></a>1.强引用(Strong Reference)</h3><p>为刚被new出来的对象所加的引用，它的特点是，永远不会被GC，除非显示的设置null，才会GC。</p>
<h3 id="2-软引用-Soft-Reference"><a href="#2-软引用-Soft-Reference" class="headerlink" title="2.软引用(Soft Reference)"></a>2.软引用(Soft Reference)</h3><p>非必须引用，内存溢出之前进行回收。如果JVM内存并不紧张，这类对象可以不被回收，如果内存紧张，则会被回收。</p>
<h3 id="3-弱引用-Weak-Reference"><a href="#3-弱引用-Weak-Reference" class="headerlink" title="3.弱引用(Weak Reference)"></a>3.弱引用(Weak Reference)</h3><p>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。</p>
<h3 id="4-虚引用-Phantom-Reference"><a href="#4-虚引用-Phantom-Reference" class="headerlink" title="4.虚引用(Phantom Reference)"></a>4.虚引用(Phantom Reference)</h3><p>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。</p>
<h2 id="五-老年代和新生代，以及Minor-GC和Major-GC"><a href="#五-老年代和新生代，以及Minor-GC和Major-GC" class="headerlink" title="五 老年代和新生代，以及Minor GC和Major GC"></a>五 老年代和新生代，以及Minor GC和Major GC</h2><p>Java虚拟机中进行垃圾回收的场所有两个，一个是堆，一个是方法区。方法区通常被称为永久代，垃圾回收的频率较低，速度也较慢。（JDK1.8之后取消永久代改为Metaspace。元空间并不在虚拟机中，而是使用本地内存）。</p>
<p>一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），特点不同，造就了他们所用的GC算法不同，新生代适合那些生命周期较短，频繁创建及销毁的对象，旧生代适合生命周期相对较长的对象。</p>
<a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/heap.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="heap" data-src="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/heap.jpg"></a>

<h3 id="1-新生代"><a href="#1-新生代" class="headerlink" title="1.新生代"></a>1.新生代</h3><p>New Generation或者Young Generation。上面大致分为Eden区和Survivor区，Survivor区又分为大小相同的两部分：FromSpace 和ToSpace。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代的大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。</p>
<h3 id="2-旧生代"><a href="#2-旧生代" class="headerlink" title="2.旧生代"></a>2.旧生代</h3><p>Old Generation。用于存放新生代中经过多次垃圾回收仍然存活的对象，例如缓存对象。旧生代占用大小为-Xmx值减去-Xmn对应的值。</p>
<h3 id="3-什么是Minor-GC和Major-GC"><a href="#3-什么是Minor-GC和Major-GC" class="headerlink" title="3.什么是Minor GC和Major GC"></a>3.什么是Minor GC和Major GC</h3><p>Minor GC是新生代GC，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死的，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>Major GC是老年代GC，指的是发生在老年代的GC，出现Major GC一般经常会伴有Minor GC，Major GC的速度比Minor GC慢的多。</p>
<h3 id="4-什么时候进行Minor-GC"><a href="#4-什么时候进行Minor-GC" class="headerlink" title="4.什么时候进行Minor GC"></a>4.什么时候进行Minor GC</h3><p>虚拟机在进行Minor GC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间</p>
<ul>
<li><p>如果大于的话，直接执行Minor GC</p>
</li>
<li><p>如果小于，JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行Major GC</p>
</li>
<li><p>如果大于的话，执行Minor GC</p>
</li>
</ul>
<p>清除 Eden 和 from ，转到to中。接下来from与to转换。继续清除 Eden和新from，转到to。清除一次后存活超过年龄的 ，转到老年代。to到了阈值后，部分对象转到老年代。</p>
<p>(至于为什么是 15次，原因是 HotSpot会在对象头的中的标记字段里记录年龄，分配到的空间只有4位，所以最多只能记录到15)</p>
<h3 id="5-什么时候进行Major-GC"><a href="#5-什么时候进行Major-GC" class="headerlink" title="5.什么时候进行Major GC"></a>5.什么时候进行Major GC</h3><ul>
<li>老年代空间不足</li>
<li>显示调用System.gc</li>
<li>MGC出现promotion failure</li>
</ul>
<p>promotion failure发生在Minor GC,  如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Major GC。</p>
<ul>
<li>统计MGC发生时晋升到老年代的平均总大小大于老年代的空闲空间</li>
</ul>
<p>在发生MGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Major GC。</p>
<p>注：<strong>许多 Major GC 是由 Minor GC 触发的</strong>，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。</p>
<h2 id="六-垃圾收集算法"><a href="#六-垃圾收集算法" class="headerlink" title="六 垃圾收集算法"></a>六 垃圾收集算法</h2><h3 id="1-标记清除算法-Mark-Sweep"><a href="#1-标记清除算法-Mark-Sweep" class="headerlink" title="1.标记清除算法 Mark-Sweep"></a>1.标记清除算法 Mark-Sweep</h3><p>标记-清除算法分为两个阶段：</p>
<ul>
<li><p>标记阶段：标记出需要被回收的对象。</p>
</li>
<li><p>清除阶段：回收被标记的可回收对象的内部空间。</p>
</li>
</ul>
<p>标记-清除算法实现较容易，不需要移动对象，但是存在较严重的问题：</p>
<ul>
<li>算法过程需要暂停整个应用，效率不高。</li>
<li>标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</li>
</ul>
<a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/Mark-Sweep.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="Mark-Sweep" data-src="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/Mark-Sweep.jpg"></a>

<h3 id="2-复制算法-Copying"><a href="#2-复制算法-Copying" class="headerlink" title="2.复制算法 Copying"></a>2.复制算法 Copying</h3><p>为了解决标志-清除算法的缺陷，由此有了复制算法。<br>复制算法将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。</p>
<p>小结：</p>
<ul>
<li>优点：实现简单，不易产生内存碎片，每次只需要对半个区进行内存回收。</li>
<li>缺点：内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。</li>
</ul>


<h3 id="3-标记整理算法-Mark-Compact"><a href="#3-标记整理算法-Mark-Compact" class="headerlink" title="3.标记整理算法 Mark-Compact"></a>3.标记整理算法 Mark-Compact</h3><p>为了更充分利用内存空间，提出了标记-整理算法。<br> 此算法结合了“标记-清除”和“复制”两个算法的优点。<br> 该算法标记阶段和“标志-清除”算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p>


<h3 id="4-分代收集算法-Generational-Collection"><a href="#4-分代收集算法-Generational-Collection" class="headerlink" title="4.分代收集算法 Generational Collection"></a>4.分代收集算法 Generational Collection</h3><p>分代收集算法是目前大部分 <code>JVM</code> 的垃圾收集器采用的算法。<br> 核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（<code>Tenured Generation</code>）和新生代（<code>Young Generation</code>），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>
<p><a href="http://facai1983.top/img/GC.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="http://facai1983.top/img/GC.jpg" class="lazyload"></a></p>
<h2 id="七-垃圾收集器"><a href="#七-垃圾收集器" class="headerlink" title="七 垃圾收集器"></a>七 垃圾收集器</h2><p>HotSpot JVM收集器</p>
<a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/JVMGC.jpg" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="JVMGC" data-src="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/JVMGC.jpg"></a>

<h3 id="1-串行回收器"><a href="#1-串行回收器" class="headerlink" title="1.串行回收器"></a>1.串行回收器</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>使用单线程进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的计算机来说，串行收集器的专注性和独占性往往有更好的性能表现。串行收集器可以在新生代和老年代中使用，根据作用于不同的堆空间，分为新生代串行收集器和老年代收集器。</p>
<p><code>-XX:+UseSerialGC</code> :年轻串行（Serial），老年串行（Serial Old）</p>
<h4 id="1-2-Serial收集器"><a href="#1-2-Serial收集器" class="headerlink" title="1.2 Serial收集器"></a>1.2 Serial收集器</h4><p>Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是JVM client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<h4 id="1-3-Serial-Old收集器"><a href="#1-3-Serial-Old收集器" class="headerlink" title="1.3 Serial Old收集器"></a>1.3 Serial Old收集器</h4><p>1、Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。<br>2、主要意义也是在于给Client模式下的虚拟机使用。<br>3、如果在Server模式下，那么它主要还有两大用途：<br>一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，<br>另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>


<h3 id="2-并行回收器"><a href="#2-并行回收器" class="headerlink" title="2.并行回收器"></a>2.并行回收器</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>多条垃圾收集线程同时进行工作,此时用户线程处于等待状态。</p>
<h4 id="2-2-ParNew收集器"><a href="#2-2-ParNew收集器" class="headerlink" title="2.2 ParNew收集器"></a>2.2 ParNew收集器</h4><p>1、Serial收集器的多线程版本<br>2、单CPU不如Serial，因为存在线程交互的开销</p>
<p>-XX:+UseParNewGC 新生代并行（ParNew），老年代串行（Serial Old）</p>
<p>-XX:ParallelGCThreads=n 设置并行收集器收集时使用的CPU数。<strong>并行收集线程数。一般最好和计算机的CPU相当</strong></p>
<h4 id="2-3-Parallel-Scavenge收集器"><a href="#2-3-Parallel-Scavenge收集器" class="headerlink" title="2.3 Parallel Scavenge收集器"></a>2.3 Parallel Scavenge收集器</h4><p>-XX:+UseParallelGC 新生代使用并行回收收集器，老年代使用串行收集器</p>
<p>1、吞吐量优先收集器<br>2、新生代收集器，复制算法，并行的多线程收集器<br>3、目标是达到一个可控制的吞吐量（Throughput）。<br>4、吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。<br>5、两个参数用于精确控制吞吐量:<br>-XX：MaxGCPauseMillis 是控制最大垃圾收集停顿时间<br>-XX：GCTimeRatio 直接设置吞吐量大小<br>-XX：+UseAdaptiveSizePolicy 动态设置新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄</p>
<h4 id="2-4-Parallel-Old收集器"><a href="#2-4-Parallel-Old收集器" class="headerlink" title="2.4 Parallel Old收集器"></a>2.4 Parallel Old收集器</h4><p>-XX:+UseParallelOldGC 新生代和老年代都使用并行回收收集器</p>
<p>1、Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。<br>2、在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/Parallel.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="Parallel" data-src="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/Parallel.png"></a>

<h3 id="3-并发回收器"><a href="#3-并发回收器" class="headerlink" title="3.并发回收器"></a>3.并发回收器</h3><h4 id="3-1-CMS-收集器"><a href="#3-1-CMS-收集器" class="headerlink" title="3.1 CMS 收集器"></a>3.1 CMS 收集器</h4><p>概念：</p>
<p>1、以获取最短回收停顿时间为目标的收集器。<br>2、非常符合互联网站或者B/S系统的服务端上，重视服务的响应速度，希望系统停顿时间最短的应用<br>3、基于“标记—清除”算法实现的<br>4、CMS收集器的内存回收过程是与用户线程一起并发执行的<br>5、它的运作过程分为4个步骤，包括：</p>
<pre><code>初始标记，“Stop The World”，只是标记一下GC Roots能直接关联到的对象，速度很快
并发标记，并发标记阶段就是进行GC RootsTracing的过程
重新标记，Stop The World”，是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，但远比并发标记的时间短
并发清除（CMS concurrent sweep）</code></pre><p>6、优点：并发收集、低停顿<br>7、缺点：</p>
<pre><code>对CPU资源非常敏感。
无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
一款基于“标记—清除”算法实现的收集器</code></pre><p>-XX:+UseConcMarkSweepGC 应用CMS收集器</p>
<p>-XX:ConcGCThreads 设置并发线程数量</p>
<p>-XX:CMSInitiatingOccupancyFraction 设置当老年代空间实用率达到百分比值时进行一次cms回收,默认为68，当老年代的空间使用率达到68%的时候，会执行CMS回收</p>
<p>如果内存使用率增长的很快，在CMS执行的过程中，已经出现了内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这回导致应用程序中断，直到垃圾回收完成后才会正常工作，这个过程GC的停顿时间可能较长，所以该值需要根据实际情况设置。</p>
<p>-XX:+UseCMSCompactAtFullCollection 设置cms在垃圾收集完成后进行一次内存碎片整理</p>
<p>-XX:CMSFullGCsBeforeCompaction 设定进行多少次cms回收后，进行一次内存压缩。</p>
<h3 id="4-并行-并发回收器"><a href="#4-并行-并发回收器" class="headerlink" title="4.并行+并发回收器"></a>4.并行+并发回收器</h3><h4 id="4-1-G1收集器"><a href="#4-1-G1收集器" class="headerlink" title="4.1 G1收集器"></a>4.1 G1收集器</h4><p>1、当今收集器技术发展的最前沿成果之一<br>2、G1是一款面向服务端应用的垃圾收集器。<br>3、优点：</p>
<pre><code>并行与并发：充分利用多CPU、多核环境下的硬件优势
分代收集：不需要其他收集器配合就能独立管理整个GC堆
空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片
可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</code></pre><p>4、G1收集器的运作大致可划分为以下几个步骤：</p>
<pre><code>初始标记：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短
并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行
最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录
筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</code></pre><p>-XX:+UserG1Gc 应用G1收集器</p>
<p>-XX:MaxGCPauseMillis 指定最大停顿时间</p>
<p>-XX:ParallelGCThreads 设置并行回收的线程数量</p>
<a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/G1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="G1" data-src="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/G1.png"></a>



<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>在众多的垃圾回收器中，没有最好的，只有最适合应用的回收器，根据应用软件的特性以及硬件平台的特点，选择不同的垃圾回收器，才能有效的提高系统性能。</p>
<h2 id="八-内存分配原则"><a href="#八-内存分配原则" class="headerlink" title="八 内存分配原则"></a>八 内存分配原则</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1.对象优先在 Eden 分配"></a>1.对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起 Minor GC。</p>
<p>大对象直接进入老年代</p>
<h3 id="2-长期存活的对象将进入老年代"><a href="#2-长期存活的对象将进入老年代" class="headerlink" title="2.长期存活的对象将进入老年代"></a>2.长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生在 Survivor 区中每熬过一次 Minor GC，年龄加 1 岁，当年龄到一定程度（默认15岁），就会晋升到老年代中。</p>
<h3 id="3-动态对象年龄判定"><a href="#3-动态对象年龄判定" class="headerlink" title="3.动态对象年龄判定"></a>3.动态对象年龄判定</h3><p>在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h3 id="4-空间分配担保"><a href="#4-空间分配担保" class="headerlink" title="4.空间分配担保"></a>4.空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可能连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这个 Minor GC 是有风险的；如果小于，或 HandlePromotionFailure 设置不允许冒险，那这次也要改为进行一次 Full GC。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">chew</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://facai1983.top/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/">http://facai1983.top/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM    </a><a class="post-meta__tags" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收    </a></div><div class="post_share"><div class="social-share" data-image="http://facai1983.top/img/GC.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.png" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%BA%A2%E5%87%BA/"><img class="prev_cover lazyload" data-src="http://facai1983.top/img/GC.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>什么是内存泄漏和内存溢出</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AF%87-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E9%83%A8%E5%88%86/"><img class="next_cover lazyload" data-src="http://facai1983.top/img/writing.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>二分查找篇-两个数组的交集部分</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'jbVBGNiWBwRavzd2W1J9xR0l-gzGzoHsz',
  appKey:'5O4E9wX4KIBNWRdKriSVX6mY',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By chew</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>